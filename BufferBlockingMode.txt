
Socket缓冲区
write()
    并不立即向网络中传输数据而是先将数据写入缓冲区中再由TCP协议将数据从缓冲区发送到目标机器一旦将数据写入到缓冲区函数就可以成功返回
    不管它们有没有到达目标机器也不管它们何时被发送到网络这些都是TCP协议负责的事情

缓冲区


            read                                              write
        /<---------输入缓冲区<------------------输出缓冲区<------------\
Server                                Net                                 Client
        \--------->输出缓冲区------------------->输入缓冲区----------->/
            write                                             read


I/O缓冲区在每个TCP套接字中单独存在
I/O缓冲区在创建套接字时自动生成
即使关闭套接字也会继续传送输出缓冲区中遗留的数据
关闭套接字将丢失输入缓冲区中的数据

关于缓冲区的大小
输入输出缓冲区的默认大小一般都是 8K可以通过 getsockopt() 函数获取
unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&optVal, &optLen);
printf("Buffer length: %d\n", optVal);



阻塞模式

对于TCP套接字(默认情况),如果使用write()发送数据时
1 检查缓冲区大小,发送数据大于缓冲区,write会被阻塞,直到缓冲区数据发送到目标机器,缓冲区有空间了,再次唤醒write()
2 如果TCP协议正在向网络发送数据,那么输出缓冲区锁定,write()阻塞,直到数据发送完毕缓冲区解锁,write()唤醒
3 写入数据大于缓冲区,则将分批写入
4 直到所有数据写入缓冲区write()才能返回


对于TCP套接字(默认情况),如果使用read()读取数据时
1 首先检查缓冲区,如果缓冲区有数据,则读取,否则read()阻塞,直到网络上有数据到来
2 如果读取的数据长度小于缓冲区的数据长度,不能将缓冲区数据一次读出,剩余的数据将积压,直到read()再次读取
3 直到读取到数据后read()才会返回,否则一直阻塞


