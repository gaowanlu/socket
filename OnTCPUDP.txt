TCP 是面向连接的传输协议建立连接时要经过三次握手断开连接时要经过四次握手中间传输数据时也要回复 ACK 包确认多种机制保证了数据能够正确到达不会丢失或出错

UDP 是非连接的传输协议没有建立连接和断开连接的过程它只是简单地把数据丢到网络中也不需要 ACK 包确认

UDP 传输数据就好像我们邮寄包裹邮寄前需要填好寄件人和收件人地址之后送到快递公司即可但包裹是否正确送达是否损坏我们无法得知也无法保证UDP 协议也是如此它只管把数据包发送到网络然后就不管了如果数据丢失或损坏发送端是无法知道的当然也不会重发

既然如此TCP 应该是更加优质的传输协议吧

如果只考虑可靠性TCP 的确比 UDP 好但 UDP 在结构上比 TCP 更加简洁不会发送 ACK 的应答消息也不会给数据包分配 Seq 序号所以 UDP 的传输效率有时会比 TCP 高出很多编程中实现 UDP 也比 TCP 简单

UDP 的可靠性虽然比不上TCP但也不会像想象中那么频繁地发生数据损毁在更加重视传输效率而非可靠性的情况下UDP 是一种很好的选择比如视频通信或音频通信就非常适合采用 UDP 协议通信时数据必须高效传输才不会产生卡顿现象用户体验才更加流畅如果丢失几个数据包视频画面可能会出现雪花音频可能会夹带一些杂音这些都是无妨的

与 UDP 相比TCP 的生命在于流控制这保证了数据传输的正确性

最后需要说明的是TCP 的速度无法超越 UDP但在收发某些类型的数据时有可能接近 UDP例如每次交换的数据量越大TCP 的传输速率就越接近于 UDP


UDP中的服务器端和客户端没有连接
UDP 不像 TCP无需在连接状态下交换数据因此基于 UDP 的服务器端和客户端
也无需经过连接过程也就是说不必调用 listen() 和 accept() 函数UDP 中只有创建套接字的过程和数据交换的过程

UDP服务器端和客户端均只需1个套接字
TCP 中套接字是一对一的关系如要向 10 个客户端提供服务那么除了负责监听的套接字外还需要创建 10 套接字但在 UDP 中不管是服务器端还是客户端都只需要 1 个套接字之前解释 UDP 原理的时候举了邮寄包裹的例子负责邮寄包裹的快递公司可以比喻为 UDP 套接字只要有 1 个快递公司就可以通过它向任意地址邮寄包裹同样只需 1 个 UDP 套接字就可以向任意主机传送数据

基于UDP的接收和发送函数
创建好 TCP 套接字后传输数据时无需再添加地址信息因为 TCP 套接字将保持与对方套接字的连接换言之TCP 套接字知道目标地址信息但 UDP 套接字不会保持连接状态每次传输数据
都要添加目标地址信息这相当于在邮寄包裹前填写收件人地址

发送数据使用sendto()函数
ssize_t sendto(int sock, void *buf, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen);  //Linux

sock用于传输 UDP 数据的套接字
buf保存待传输数据的缓冲区地址
nbytes带传输数据的长度以字节计
flags可选项参数若没有可传递 0
to存有目标地址信息的 sockaddr 结构体变量的地址
addrlen传递给参数 to 的地址值结构体变量的长度

UDP 发送函数 sendto() 与TCP发送函数 write()的最大区别在于sendto() 函数需要向他传递目标地址信息
接收数据使用 recvfrom() 函数

ssize_t recvfrom(int sock, void *buf, size_t nbytes, int flags, struct sockadr *from, socklen_t *addrlen);  //Linux
sock用于接收 UDP 数据的套接字
buf保存接收数据的缓冲区地址
nbytes可接收的最大字节数不能超过 buf 缓冲区的大小
flags可选项参数若没有可传递 0
from存有发送端地址信息的 sockaddr 结构体变量的地址
addrlen保存参数 from 的结构体变量长度的变量地址值

UDP回声windows代码
Server
//创建套接字
    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);
 
    //绑定套接字
    sockaddr_in servAddr;
    memset(&servAddr, 0, sizeof(servAddr));  //每个字节都用0填充
    servAddr.sin_family = PF_INET;  //使用IPv4地址
    servAddr.sin_addr.s_addr = htonl(INADDR_ANY); //自动获取IP地址
    servAddr.sin_port = htons(1234);  //端口
    bind(sock, (SOCKADDR*)&servAddr, sizeof(SOCKADDR));
 
    //接收客户端请求
    SOCKADDR clntAddr;  //客户端地址信息
    int nSize = sizeof(SOCKADDR);
    char buffer[BUF_SIZE];  //缓冲区
    while(1){
        int strLen = recvfrom(sock, buffer, BUF_SIZE, 0, &clntAddr, &nSize);
        sendto(sock, buffer, strLen, 0, &clntAddr, nSize);
    }
 
    closesocket(sock);
向 socket() 第二个参数传递 SOCK_DGRAM以指明使用 UDP 协议
使用htonl(INADDR_ANY)来自动获取 IP 地址
利用常数 INADDR_ANY 自动获取 IP 地址有一个明显的好处就是当软件安装到其他服务器或者服务器 IP 地址改变时不用
再更改源码重新编译也不用在启动软件时手动输入而且如果一台计算机
中已分配多个 IP 地址例如路由器那么只要端口号一致就可
以从不同的 IP 地址接收数据所以服务器中优先考虑使用 INADDR_ANY而客户端中除非带有一部分服务器功能否则不会采用

Client

//创建套接字
    SOCKET sock = socket(PF_INET, SOCK_DGRAM, 0);
 
    //服务器地址信息
    sockaddr_in servAddr;
    memset(&servAddr, 0, sizeof(servAddr));  //每个字节都用0填充
    servAddr.sin_family = PF_INET;
    servAddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    servAddr.sin_port = htons(1234);
 
    //不断获取用户输入并发送给服务器然后接受服务器数据
    sockaddr fromAddr;
    int addrLen = sizeof(fromAddr);
    while(1){
        char buffer[BUF_SIZE] = {0};
        printf("Input a string: ");
        gets(buffer);
        sendto(sock, buffer, strlen(buffer), 0, (struct sockaddr*)&servAddr, sizeof(servAddr));
        int strLen = recvfrom(sock, buffer, BUF_SIZE, 0, &fromAddr, &addrLen);
        buffer[strLen] = 0;
        printf("Message form server: %s\n", buffer);
    }
 
    closesocket(sock);

server.cpp 中没有使用 listen() 函数client.cpp 中也没有使用 connect() 函数因为 UDP 不需要连接










