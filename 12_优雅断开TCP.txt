优雅地断开TCP连接
调用 close()/closesocket() 函数意味着完全断开连接即不能发送数据也不能接收数据这种生硬的方式有时候会显得不太优雅.

A<---B
 ---->

A断开后A不能操作了 B也无法操作了

但有些情况下,需要只断开一条数据传输道路,保留另一条

shutdown()函数
int shutdown(int sock,int howto);//linux

sock为需要断开的套接字,howto为断开方式
howto 在 Linux 下有以下取值

SHUT_RD断开输入流套接字无法接收数据即使输入缓冲区收到数据也被抹去无法调用输入相关函数
SHUT_WR断开输出流套接字无法发送数据但如果输出缓冲区中还有未传输的数据则将传递到目标主机
SHUT_RDWR同时断开 I/O 流相当于分两次调用 shutdown()其中一次以 SHUT_RD 为参数另一次以 SHUT_WR 为参数

close()/closesocket()和shutdown()的区别

确切地说close() / closesocket() 用来关闭套接字将套接字描述符或句柄从内存清除之后再也不能使用该套接字与C语言中的 fclose() 类似应用程序关闭套接字后与该套接字相关的连接和缓存也失去了意义TCP协议会自动触发关闭连接的操作

shutdown() 用来关闭连接而不是套接字不管调用多少次 shutdown()套接字依然存在直到调用 close() / closesocket() 将套接字从内存清除

调用 close()/closesocket() 关闭套接字时或调用 shutdown() 关闭输出流时都会向对方发送 FIN 包FIN 包表示数据传输完毕计算机收到 FIN 包就知道不会再有数据传送过来了

默认情况下close()/closesocket() 会立即向网络中发送FIN包不管输出缓冲区中是否还有数据而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包也就意味着调用 close()/closesocket() 将丢失输出缓冲区中的数据而调用 shutdown() 不会
